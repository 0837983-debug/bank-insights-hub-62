# Roadmap: DataSourceKey + SQL Builder + Buttons

## Контекст
Цель: убрать разрозненные сервисы с SQL, перейти на единый getData, где SQL строится из конфигов в БД. Кнопки и header становятся компонентами с data_source_key.

## Последовательность (по 1–2 задачи)

### Шаг 1 — Таблица запросов + базовые конфиги ✅
**Смысл:** создать единый источник конфигов для SQL builder.
- Создать таблицу `config.component_queries`.
- Добавить конфиги **только** для:
  - header_dates
  - assets_table
- Не трогаем kpis/layout (там join).

### Шаг 2 — SQL builder v1 ✅
**Смысл:** builder получает query_id и params, читает конфиг из БД, возвращает SQL.
- Подставляет значения, возвращает готовый SQL (без массива params).
- Оборачивает строки/даты в `'...'`.

### Шаг 3 — SQL builder v2 (wrapJson) ✅
**Смысл:** конфиг управляет тем, должен ли результат быть агрегирован в JSON.
- Добавить `wrapJson: true|false`.
- При true — оборачивать в `jsonb_agg(...)`.

### Шаг 4 — Новый endpoint getData ✅
**Смысл:** единая точка данных.
- Принимает `query_id + params`.
- Вызывает builder, исполняет SQL, возвращает JSON.

### Шаг 5 — Header как компонент ✅
**Смысл:** header получает даты через data_source_key.
- Добавить header в `config.components`.
- Указать `data_source_key = header_dates`.
- Пока **один** data_source_key.

### Шаг 6 — Layout возвращает data_source_key ✅
**Смысл:** фронт видит, что и откуда грузить.
- Вернуть data_source_key для всех компонентов, где он заполнен.
 - Доработать фронт: при вызовах API передавать даты, полученные при загрузке header.

### Шаг 7 — Кнопка как компонент ✅
**Смысл:** заменить groupableFields на кнопки.
- Создать компонент `button`.
- Привязать к таблице через parent_component_id.
- Перенести groupableFields в кнопки.
- Удалить groupableFields из layout.
- Позже: разрешить кнопки у любых компонентов.

### Шаг 8 — Header как отдельный top‑level элемент ✅
**Смысл:** header рендерится над секциями, не является контейнером.
- В БД: component_type для header = `header` (не `container`).
- Layout API: возвращать header отдельно (например `layout.header`).
- Frontend: рендерить header над секциями на основе layout.

### Шаг 9 — Перенести layout на Data API ✅
**Смысл:** layout получает данные через единый data API.
- Перенести layout на getData.
- Настроить фронт на использование api/data для получения layout.

### Шаг 10 — Добавить layout_id в layout ✅
**Смысл:** layout содержит свой layout_id для фильтрации/связей.
- Добавить layout_id в ответ layout.

### Шаг 11 — Перенести KPI на Data API ✅
**Смысл:** KPI получают данные через единый data API.
- Перенести KPI на getData.

### Шаг 12 — Проценты (YTD, PPTD)
**Смысл:** расчет процентов выполняется на фронте единой функцией.
- Считать на фронте единой функцией.
- На бэке проценты не считать.

### Шаг 13 — Проценты по строке
**Смысл:** расчет % от суммы по строке для таблиц на фронте.
- Сделать на фронте функцию расчета % от суммы по строке для таблиц.

## Примечания
- join пока не поддерживается в конфиге.
- kpis/layout переносим отдельно позже.
- Header дат — первый потребитель getData.

## Дополнения (зафиксировать на будущее)
1) Перенос KPI и layout на новый getData:
   - Перед этим нужен view для layout (jsonb_agg или агрегаты по полям),
     чтобы можно было фильтровать по layout_id и отдавать один layout.
2) Универсальный api/data:
   - Переделать api/data на универсальный сервис.
   - Отдавать данные по component_id, без привязки к конкретным таблицам (assets_table и т.д.).
   - Логика: component_id → data_source_key (из config.components) → query_id → SQL builder.
3) JSON параметры в getData:
   - Переделать api/data на прием params как JSON (вместо отдельных query params).
   - Формат: `/api/data/:query_id?params={"p1":"2025-12-31","p2":"2025-11-30","p3":"2024-12-31"}`
   - Обновить фронт для передачи JSON.
