# Roadmap: DataSourceKey + SQL Builder + Buttons

## Контекст
Цель: убрать разрозненные сервисы с SQL, перейти на единый getData, где SQL строится из конфигов в БД. Кнопки и header становятся компонентами с data_source_key.

## Последовательность (по 1–2 задачи)

### Шаг 1 — Таблица запросов + базовые конфиги
**Смысл:** создать единый источник конфигов для SQL builder.
- Создать таблицу `config.component_queries`.
- Добавить конфиги **только** для:
  - header_dates
  - assets_table
- Не трогаем kpis/layout (там join).

### Шаг 2 — SQL builder v1
**Смысл:** builder получает query_id и params, читает конфиг из БД, возвращает SQL.
- Подставляет значения, возвращает готовый SQL (без массива params).
- Оборачивает строки/даты в `'...'`.

### Шаг 3 — SQL builder v2 (wrapJson)
**Смысл:** конфиг управляет тем, должен ли результат быть агрегирован в JSON.
- Добавить `wrapJson: true|false`.
- При true — оборачивать в `jsonb_agg(...)`.

### Шаг 4 — Новый endpoint getData
**Смысл:** единая точка данных.
- Принимает `query_id + params`.
- Вызывает builder, исполняет SQL, возвращает JSON.

### Шаг 5 — Header как компонент
**Смысл:** header получает даты через data_source_key.
- Добавить header в `config.components`.
- Указать `data_source_key = header_dates`.
- Пока **один** data_source_key.

### Шаг 6 — Layout возвращает data_source_key
**Смысл:** фронт видит, что и откуда грузить.
- Вернуть data_source_key для всех компонентов, где он заполнен.
 - Доработать фронт: при вызовах API передавать даты, полученные при загрузке header.

### Шаг 7 — Кнопка как компонент
**Смысл:** заменить groupableFields на кнопки.
- Создать компонент `button`.
- Привязать к таблице через parent_component_id.
- Перенести groupableFields в кнопки.
- Удалить groupableFields из layout.
- Позже: разрешить кнопки у любых компонентов.

### Шаг 8 — Перевести select’ы на getData
**Смысл:** отказаться от старых endpoint’ов и SQL в сервисах.
- Перенести assets, kpis, layout (отдельно).
- Удалить старые вызовы.

### Шаг 9 — Header как отдельный top‑level элемент
**Смысл:** header рендерится над секциями, не является контейнером.
- В БД: component_type для header = `header` (не `container`).
- Layout API: возвращать header отдельно (например `layout.header`).
- Frontend: рендерить header над секциями на основе layout.

## Примечания
- join пока не поддерживается в конфиге.
- kpis/layout переносим отдельно позже.
- Header дат — первый потребитель getData.

## Дополнения (зафиксировать на будущее)
1) Перенос KPI и layout на новый getData:
   - Перед этим нужен view для layout (jsonb_agg или агрегаты по полям),
     чтобы можно было фильтровать по layout_id и отдавать один layout.
2) Проценты (YTD, PPTD):
   - Считать на фронте единой функцией.
   - На бэке проценты не считать.
3) Проценты по строке:
   - Сделать на фронте функцию расчета % от суммы по строке для таблиц.
4) Универсальный api/data:
   - Переделать api/data на универсальный сервис.
   - Отдавать данные по component_id, без привязки к конкретным таблицам (assets_table и т.д.).
   - Логика: component_id → data_source_key (из config.components) → query_id → SQL builder.
5) JSON параметры в getData:
   - Переделать api/data на прием params как JSON (вместо отдельных query params).
   - Формат: `/api/data/:query_id?params={"p1":"2025-12-31","p2":"2025-11-30","p3":"2024-12-31"}`
   - Обновить фронт для передачи JSON.
